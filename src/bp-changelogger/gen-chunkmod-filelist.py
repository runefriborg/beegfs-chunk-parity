#!/usr/bin/python2
# -*- coding: utf-8 -*-
from __future__ import with_statement

import os
import sys
import time
import fcntl
import struct
import optparse

chunks_modified = {}

FILEMOD_PATH = "/dev/shm/beegfs-changelog"

def get_files(path, store):
    for (dirpath, dirnames, filenames) in os.walk(path):
        for name in filenames:
            yield os.path.join(path, name)
        break # no sub dirs, just the one level

def write_to_stdout():
    ''' Convert entry into easy C parseble types.
        * 8-byte unsigned int for timestamp followed by
        * 8-byte char's contaning either 'd' or 'm' (delete and modify). Must
          be padded to fit nicely into the parseble format
        * 8-byte unsigned int denoting the lenght of the coming string
        * The string itself

        Repeat this pattern without any seperators.

        Write output to stdout.'''

    for path,(timestamp,type,size) in chunks_modified.items():
        time_b = struct.pack('<Q',int(timestamp))
        size_b = struct.pack('<Q',int(size))
        len_b  = struct.pack('<Q',len(path))
        assert len(type) is 1
        type_b  = struct.pack('<Q',long(ord(type)))

        sys.stdout.write(time_b+size_b+type_b+len_b+path)

def insert(entries):
    ''' Weed out all but the newest entry for each chunk.
        If timestamp_1 == timestamp_2, type='d' takes precedent.'''

    for timestamp,type,path,size in entries:
        if path in chunks_modified and timestamp < chunks_modified[path][0]:
            continue
        elif path in chunks_modified and timestamp == chunks_modified[path][0] and type is not 'd':
            continue
        else:
            chunks_modified[path] = (timestamp,type,size)

def parse(file,store):
    ''' Takes a string as input and parses it into tuples of (timestamp, type,
        path).
        One log file per thread ensures that input is sorted by timestamp.'''

    start = len(store)
    valid_entries = []
    for entry in file:
        timestamp,type,path = entry.strip().split(' ')
        timestamp = int(timestamp)
        if path.startswith(store):
            if type != 'd':
                try:
                    stat = os.stat(path)
                    size = stat.st_size
                except:
                    size = 0
            else:
                size = 0
            valid_entries.append((timestamp,type,path[start:],size))

    return valid_entries


def construct_chunkmod_data(path, store, deletable_files):
    for filename in get_files(path, store):
        with open(filename,'r') as f:
            entries = parse(f, store)
            insert(entries)
            if len(entries) != 0:
                try:
                    fcntl.flock(f.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
                    # The file-lock was available, it is safe to delete this file
                    deletable_files.write(filename + "\n")
                except IOError:
                    pass

    write_to_stdout()

def cleanup_until(targets):
    for line in open(targets):
        try:
            os.unlink(line.strip())
        except:
            pass


def main():
    parser = optparse.OptionParser(usage="""Usage: %prog --deletable <file> --store <store prefix> [--cleanup]"

%prog constructs a list of files that have been modified.
It does this by looking at the logs files generated by a LD_PRELOAD'ed
change-logger module for the beegfs-storage daemon.

The output format is constructed to be easy parseable in C.
Format: <time><type><len><str>
    time: 8 byte unsigned int timestamp of the event
    type: a char packed into 8 bytes, to make the parsing more clean
    len: 8 byte unsigned int denoting the length of the path name
    str: char array of the above length with the path of the file

    note: no NULL byte at the end of str
""",
                                   version="%prog 1.0")
    parser.add_option("-d", "--deletable" , dest="del_f", type="string",
                      help="Store a list of files that are safe to delete here", metavar="FILE")
    parser.add_option("-s", "--store", dest="store"  , type="string",
                      help="Store to work on", metavar="STORE")
    parser.add_option("-c", "--cleanup" , dest="cleanup", action="store_true",
                      default=False, help="Delete the files")

    (options, args) = parser.parse_args()

    if not options.del_f:
        parser.error("No location for storing deletable files given")
        sys.exit(1)

    if options.cleanup:
        cleanup_until(options.del_f)
    elif not options.store:
        print parser.usage
    else:
        if options.store[0] != "/":
            options.store = "/"+options.store

        deletable_files = open(options.del_f, "a")
        construct_chunkmod_data(FILEMOD_PATH, options.store, deletable_files)

if __name__ == "__main__":
    main()
